type Tx {
  transaction_hash: String!
  txLink: Transaction
    @materializer(
      query: "transaction"
      arguments: [{ name: "id", field: "transaction_hash" }]
    )
  detail(apikey: String!): TXDetail
    @materializer(
      query: "tx_details"
      arguments: [
        { name: "txhash", field: "transaction_hash" }
        { name: "apikey", argument: "apikey" }
      ]
    )
}

type TxEdge {
  node: Tx
  cursor: String
}

type TxConnection {
  pageInfo: PageInfo!
  edges: [TxEdge]
}

type Swap {
  amount0: String
  amount1: String
  amountUSD: String
  id: String
  sqrtPriceX96: String
  tick: String
}

type Transaction {
  swaps: [Swap]
}

type Root {
  result: [Tx]
  cursor: String
  page: Int
  page_size: Int
  total: Int
}

type Token0 {
  name: String
}

type Token1 {
  name: String
}

type Pool {
  feeTier: String
  id: String
  token0: Token0
  token1: Token1
  volumeUSD: String
}

type Price {
  amount: String
  base: String
  currency: String
}

type PriceRoot {
  data: Price
}

type Challenge {
  text: String
}

type Data {
  challenge: Challenge
}

type RootChallenge {
  data: Data
}

type Request {
  address: String
}

input ChallengeRequest {
  address: String!
}

scalar Signature

input SignedAuthChallenge {
  """
  The ethereum address you signed the signature with
  """
  address: String!
  """
  The signature
  """
  signature: Signature!
}
scalar Jwt

type AuthenticationResult {
  """
  The access token
  """
  accessToken: Jwt!
  """
  The refresh token
  """
  refreshToken: Jwt!
}
scalar ProfileId
scalar Url
scalar Handle
scalar EthereumAddress
union ProfileMedia = NftImage | MediaSet

"""
The NFT image
"""
type NftImage {
  """
  The contract address
  """
  contractAddress: ContractAddress!
  """
  The token id of the nft
  """
  tokenId: String!
  """
  The token image nft
  """
  uri: Url!
  """
  The token image nft
  """
  chainId: Int!
  """
  If the NFT is verified
  """
  verified: Boolean!
}

"""
Contract address custom scalar type
"""
scalar ContractAddress

"""
The Media Set
"""
type MediaSet {
  """
  Original media
  """
  original: Media!
  """
  Small media - will always be null on the public API
  """
  small: Media
  """
  Medium media - will always be null on the public API
  """
  medium: Media
}

"""
The Media url
"""
type Media {
  """
  The token image nft
  """
  url: Url!
  """
  Width - will always be null on the public API
  """
  width: Int
  """
  Height - will always be null on the public API
  """
  height: Int
  """
  Size - will always be null on the public API
  """
  size: Int
  """
  The image/audio/video mime type for the publication
  """
  mimeType: MimeType
}

"""
mimetype custom scalar type
"""
scalar MimeType

"""
The dispatcher
"""
type Dispatcher {
  """
  The dispatcher address
  """
  address: EthereumAddress!
  """
  If the dispatcher can use the relay
  """
  canUseRelay: Boolean!
}

type Profile {
  # The profile id
  id: ProfileId!

  # Name of the profile
  name: String

  # Bio of the profile
  bio: String

  # Follow nft address
  followNftAddress: ContractAddress

  # Metadata url
  metadata: Url

  # The profile handle
  handle: Handle!
  # The picture for the profile
  picture: ProfileMedia
  # The cover picture for the profile
  coverPicture: ProfileMedia

  # Who owns the profile
  ownedBy: String!

  nftlist(apikey: String): NFTList
    @materializer(
      query: "list_nft"
      arguments: [
        { name: "address", field: "ownedBy" }
        { name: "apikey", argument: "apikey" }
      ]
    )

  # The dispatcher
  dispatcher: Dispatcher

  # Profile stats
  stats: ProfileStats!

  # The follow module
  followModule: FollowModule

  # Is the profile default
  isDefault: Boolean!

  # Optionals param to add extra attributes on the metadata
  attributes: [Attribute!]
  isFollowedByMe: Boolean!
  isFollowing(who: ProfileId): Boolean!
}

type ProfileStats {
  """
  Total follower count
  """
  totalFollowers: Int!
  """
  Total following count (remember the wallet follows not profile so will be same for every profile they own)
  """
  totalFollowing: Int!
  """
  Total post count
  """
  totalPosts: Int!
  """
  Total comment count
  """
  totalComments: Int!
  """
  Total mirror count
  """
  totalMirrors: Int!
  """
  Total publication count
  """
  totalPublications: Int!
  """
  Total collects count
  """
  totalCollects: Int!
}

union FollowModule = FeeFollowModuleSettings

type FeeFollowModuleSettings {
  """
  The follow modules enum
  """
  type: FollowModules!
  contractAddress: ContractAddress!
  """
  The collect module amount info
  """
  amount: ModuleFeeAmount!
  """
  The collect module recipient address
  """
  recipient: EthereumAddress!
}

"""
The follow module types
"""
enum FollowModules {
  FeeFollowModule
}

type ModuleFeeAmount {
  """
  The erc20 token info
  """
  asset: Erc20!
  """
  Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal.
  """
  value: String!
}

"""
The erc20 type
"""
type Erc20 {
  """
  Name of the symbol
  """
  name: String!
  """
  Symbol for the token
  """
  symbol: String!
  """
  Decimal places for the token
  """
  decimals: Int!
  """
  The erc20 address
  """
  address: ContractAddress!
}

"""
The Profile
"""
type Attribute {
  """
  The display type
  """
  displayType: MetadataDisplayType
  """
  The trait type - can be anything its the name it will render so include spaces
  """
  traitType: String!
  """
  identifier of this attribute, we will update by this id
  """
  key: String!
  """
  Value attribute
  """
  value: String!
}

"""
The metadata display types
"""
enum MetadataDisplayType {
  number
  string
  date
}

type NFT {
  amount: String
  block_number: String
  block_number_minted: String
  contract_type: String
  last_metadata_sync: DateTime
  last_token_uri_sync: DateTime
  metadata: String
  name: String
  owner_of: String
  symbol: String
  token_address: String
  token_hash: String
  token_id: String
  token_uri: String
}

type NFTList {
  cursor: String
  page: Int
  page_size: Int
  result: [NFT]
  status: String
  total: Int
}

type Balance {
  balance: String
}

type Tweet {
  id: String
  text: String
}

type Meta {
  newest_id: String
  next_token: String
  oldest_id: String
  result_count: Int
}

type Tweets {
  data: [Tweet]
  meta: Meta
}

type DataCryptoCompareTX {
  active_addresses: Int
  average_transaction_value: Float
  block_height: Int
  block_size: Int
  block_time: Float
  current_supply: Float
  difficulty: Int
  hashrate: Float
  id: Int
  large_transaction_count: Int
  new_addresses: Int
  symbol: String
  time: Int
  transaction_count: Int
  transaction_count_all_time: Int
  unique_addresses_all_time: Int
  zero_balance_addresses_all_time: Int
}

type DataCryptoCompare {
  Aggregated: Boolean
  Data: [DataCryptoCompareTX]
  TimeFrom: Int
  TimeTo: Int
}

type CryptoCompare {
  Data: DataCryptoCompare
  HasWarning: Boolean
  Message: String
  RateLimit: JSON
  Response: String
  Type: Int
}

type Log {
  address: String
  block_hash: String
  block_number: String
  block_timestamp: DateTime
  data: String
  log_index: String
  topic0: String
  topic1: String
  topic2: String
  topic3: JSON
  transaction_hash: String
  transaction_index: String
  transaction_value: String
  transfer_index: [Int]
}

type TXDetail {
  block_hash: String
  block_number: String
  block_timestamp: DateTime
  from_address: String
  gas: String
  gas_price: String
  hash: String
  input: String
  logs: [Log]
  nonce: String
  receipt_contract_address: JSON
  receipt_cumulative_gas_used: String
  receipt_gas_used: String
  receipt_root: JSON
  receipt_status: String
  to_address: String
  transaction_index: String
  transfer_index: [Int]
  value: String
}

type Query {
  historical_crypto(token: String!, apikey: Secret!): CryptoCompare
    @rest(
      method: GET
      endpoint: "https://min-api.cryptocompare.com/data/blockchain/histo/day?fsym=$token"
      headers: [{ name: "authorization", value: "Apikey $apikey" }]
    )

  pools(first: Int, orderBy: String, orderDirection: String): [Pool]
    @graphql(
      endpoint: "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3"
    )

  get_price(pair: String!): PriceRoot
    @rest(
      method: GET
      endpoint: "https://api.coinbase.com/v2/prices/$pair/spot"
    )

  tx_details(txhash: String!, apikey: String!): TXDetail
    @rest(
      method: GET
      endpoint: "https://deep-index.moralis.io/api/v2/transaction/$txhash?chain=eth"
      headers: [{ name: "X-API-Key", value: "$apikey" }]
    )
  list_nft(address: String!, apikey: String!): NFTList
    @rest(
      method: GET
      endpoint: "https://deep-index.moralis.io/api/v2/$address/nft?chain=eth&format=decimal"
      headers: [{ name: "X-API-Key", value: "$apikey" }]
    )

  get_balance(address: String!, apikey: String!): Balance
    @rest(
      method: GET
      endpoint: "https://deep-index.moralis.io/api/v2/$address/balance?chain=eth"
      headers: [{ name: "X-API-Key", value: "$apikey" }]
    )

  get_tweets(query: String!, authorization: Secret!): Tweets
    @rest(
      method: GET
      endpoint: "https://api.twitter.com/2/tweets/search/recent?query=$query"
      headers: [{ name: "authorization", value: "$authorization" }]
    )

  list_of_transactions_pool(
    address: String!
    after: String = ""
    first: Int! = 20
    apikey: String!
  ): Root
    @rest(
      method: GET
      endpoint: "https://deep-index.moralis.io/api/v2/$address/logs?chain=eth&cursor=$after"
      headers: [{ name: "X-API-Key", value: "$apikey" }]
    )

  transaction(id: String!): Transaction
    @graphql(
      endpoint: "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3"
    )

  """
  Querys for Lens
  """
  challenge(request: ChallengeRequest!): Challenge
    @graphql(endpoint: "https://api-mumbai.lens.dev")

  recommendedProfiles: [Profile!]! @graphql(endpoint: "https://api.lens.dev/")
}

type Mutation {
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!
    @graphql(endpoint: "https://api-mumbai.lens.dev/")
}
